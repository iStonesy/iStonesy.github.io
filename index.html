<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.4.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！">
<meta property="og:type" content="website">
<meta property="og:title" content="小马同学的技术博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="小马同学的技术博客">
<meta property="og:description" content="iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小马同学的技术博客">
<meta name="twitter:description" content="iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！">






  <link rel="canonical" href="http://yoursite.com/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>小马同学的技术博客</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小马同学的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Stay hungry. Stay Foolish. - Steve Jobs. 求知若渴，虚心若愚！</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/24/4.Cycript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小马同学">
      <meta itemprop="description" content="iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小马同学的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/24/4.Cycript/" itemprop="url">
                  Cycript
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-24 02:05:00" itemprop="dateCreated datePublished" datetime="2018-10-24T02:05:00+08:00">2018-10-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-10-28 02:59:18" itemprop="dateModified" datetime="2018-10-28T02:59:18+08:00">2018-10-28</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/逆向实战/" itemprop="url" rel="index"><span itemprop="name">逆向实战</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>iOS | Cycript | Objective-C</p>
<h2><span id="cycript">Cycript</span></h2><ul>
<li>Cycript是Objective-C++、ES6（JavaScript）、Java等语法的混合物</li>
<li>可以用来探索、修改、调试正在运行的Mac\iOS APP</li>
<li>官网：<a href="http://www.cycript.org/" target="_blank" rel="noopener">http://www.cycript.org/</a></li>
<li>文档：<a href="http://www.cycript.org/manual/" target="_blank" rel="noopener">http://www.cycript.org/manual/</a></li>
<li>通过Cydia安装Cycript，即可在iPhone上调试运行中的APP<br><a href="4.Cycript/Cycript.png">Cycript</a></li>
</ul>
<h2><span id="cycript-的开启和关闭">Cycript 的开启和关闭</span></h2><ul>
<li><strong>开启</strong><br>1&gt; cycript<br>2&gt; cycript -p 进程ID<br>3&gt; cycript -p 进程名称<br><img src="/2018/10/24/4.Cycript/Cycript_open_close.png" alt="Cycript_open_close"></li>
<li><strong>取消输入：Ctrl + C</strong></li>
<li><strong>退出：Ctrl + D</strong></li>
<li><strong>清屏：Command + R</strong></li>
</ul>
<h2><span id="ps命令">ps命令</span></h2><ul>
<li>安装adv-cmds<br><img src="/2018/10/24/4.Cycript/ps.png" alt="ps"></li>
<li>ps命令是process status的缩写，使用ps命令可以列出系统当前的进程<br>1&gt; 列出所有的进程<br><strong>ps –A</strong><br><strong>ps aux</strong><br>2&gt; 搜索关键词<br><strong>ps –A | grep 关键词</strong></li>
</ul>
<h2><span id="常用语法">常用语法</span></h2><ul>
<li><strong>UIApp</strong><br>[UIApplication sharedApplication]</li>
<li><strong>定义变量</strong><br>var 变量名 = 变量值</li>
<li><strong>用内存地址获取对象</strong><br>#内存地址</li>
<li><strong>ObjectiveC.classes</strong><br>已加载的所有OC类</li>
<li><strong>查看对象的所有成员变量</strong><br>*对象<br><img src="/2018/10/24/4.Cycript/常用语法.png" alt="常用语法"></li>
</ul>
<hr>
<ul>
<li><strong>递归打印view的所有子控件（跟LLDB一样的函数）</strong><br>view.recursiveDescription().toString()</li>
<li>筛选出某种类型的对象<br>choose(UIViewController)<br>choose(UITableViewCell)</li>
</ul>
<h2><span id="封装cycript-cy文件编写">封装Cycript - .cy文件编写</span></h2><ul>
<li>我们可以将常用的Cycript代码封装在一个.cy文件中</li>
<li>exports参数名固定，用于向外提供接口<br><img src="/2018/10/24/4.Cycript/封装Cycript.png" alt="cy文件编写"></li>
</ul>
<hr>
<p><strong>封装Cycript - 存放和使用.cy文件：</strong><br>1&gt; 将.cy文件存放到/usr/lib/cycript0.9目录下<br>2&gt; 在Cycript中引用.cy文件，并使用它提供的接口<br><img src="/2018/10/24/4.Cycript/cy文件存放.png" alt="cy文件存放、使用"></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/23/3.SSH/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小马同学">
      <meta itemprop="description" content="iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小马同学的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/23/3.SSH/" itemprop="url">
                  SSH(下)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-23 22:05:00" itemprop="dateCreated datePublished" datetime="2018-10-23T22:05:00+08:00">2018-10-23</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-10-28 02:11:24" itemprop="dateModified" datetime="2018-10-28T02:11:24+08:00">2018-10-28</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/逆向实战/" itemprop="url" rel="index"><span itemprop="name">逆向实战</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>iOS | SSH | Objective-C</p>
<h2><span id="1通过usb进行ssh登录">1.通过USB进行SSH登录</span></h2><ul>
<li><p><strong>默认情况下，由于SSH走的是TCP协议，Mac是通过网络连接的方式SSH登录到iPhone，要求iPhone连接WiFi</strong><br><img src="/2018/10/23/3.SSH/SSH_Default.png" alt="SSH_Default"></p>
</li>
<li><p><strong>为了加快传输速度，也可以通过USB连接的方式进行SSH登录</strong><br>1&gt; Mac上有个服务程序usbmuxd（它会开机自动启动），可以将Mac的数据通过USB传输到iPhone：<br>/System/Library/PrivateFrameworks/MobileDevice.framework/Resources/usbmuxd<br><img src="/2018/10/23/3.SSH/SSH_USB.png" alt="SSH_USB"></p>
</li>
</ul>
<h2><span id="2usbmuxd的使用">2.usbmuxd的使用</span></h2><ul>
<li>下载usbmuxd工具包（下载v1.0.8版本，主要用到里面的一个python脚本：<strong>tcprelay.py</strong>）<br><a href="https://cgit.sukimashita.com/usbmuxd.git/snapshot/usbmuxd-1.0.8.tar.gz" target="_blank" rel="noopener">https://cgit.sukimashita.com/usbmuxd.git/snapshot/usbmuxd-1.0.8.tar.gz</a><br>如果下载失败，可尝试点此下载：<a href="/download/SSH/usbmuxd-1.0.8.tar.gz">usbmuxd-1.0.8.tar.gz</a></li>
<li><strong>将iPhone的22端口（SSH端口）映射到Mac本地的10010端口</strong><br>1&gt; <strong>cd ~/Documents/usbmuxd-1.0.8/python-client</strong><br>2&gt; <strong>python tcprelay.py -t 22:10010</strong><br>加上-t参数是为了能够同时支持多个SSH连接<br><img src="/2018/10/23/3.SSH/tcprelay_01.png" alt="tcprelay"></li>
<li><strong>注意：要想保持端口映射状态，不能终止此命令行（如果要执行其他终端命令行，请新开一个终端界面）</strong></li>
<li>不一定非要10010端口，只要不是保留端口就行</li>
</ul>
<hr>
<ul>
<li><strong>端口映射完毕后，以后如果想跟iPhone的22端口通信，直接跟Mac本地的10010端口通信就可以了</strong></li>
<li>新开一个终端界面，SSH登录到Mac本地的10010端口（以下方式2选1）<br>1&gt; <strong>ssh root@localhost -p 10010</strong><br>2&gt; <strong>ssh <a href="mailto:root@192.168.31.26" target="_blank" rel="noopener">root@192.168.31.26</a> -p 10010</strong><br>注：(1) localhost是一个域名，指向的IP地址是192.168.31.26，本机虚拟网卡的IP地址<br>(2) usbmuxd会将Mac本地10010端口的TCP协议数据，通过USB连接转发到iPhone的22端口</li>
<li><strong>远程拷贝文件也可以直接跟Mac本地的10010端口通信</strong><br>1&gt; <strong>scp -P 10010 ~/Desktop/test.txt root@localhost:~/test</strong><br>2&gt; 将Mac上的<strong>~/Desktop/test.txt</strong>文件，拷贝到iPhone上的<strong>~/test</strong>路径<br><strong>注意：</strong>scp的端口号参数是大写的-P</li>
</ul>
<h2><span id="3sh脚本文件">3.sh脚本文件</span></h2><ul>
<li><strong>我们可以将经常执行的一系列终端命令行(比如：刚才提到的端口映射、ssh登录)放到sh脚本文件中（shell），然后执行脚本文件</strong><br><img src="/2018/10/23/3.SSH/testCD_sh.png" alt="testCD_sh"></li>
<li>可以通过sh、bash、source命令来执行sh脚本文件<br><strong>sh、bash:</strong><br>1&gt; 当前shell环境会启动一个子进程来执行脚本文件，执行后返回到父进程的shell环境<br>2&gt; 执行cd时，在子进程中会进入到cd的目录，但是在父进程中环境并没有改变，也就是说目录没有改变<br><strong>source:</strong><br>1&gt; 在当前的shell环境下执行脚本文件<br>2&gt; 执行cd后会跳转到cd的目录<br><img src="/2018/10/23/3.SSH/sh_bash_source.png" alt="sh_bash_source"></li>
</ul>
<h2><span id="4ios终端的中文乱码问题">4.iOS终端的中文乱码问题</span></h2><ul>
<li>默认情况下，iOS终端不支持中文输入和显示</li>
<li>解决方案：新建一个<strong>~/.inputrc</strong>文件，文件内容是<br>1&gt; 不将中文字符转化为转义序列 :<br><strong>set convert-meta off</strong><br>2&gt; 允许向终端输出中文:<br><strong>set output-meta on</strong><br>3&gt; 允许向终端输入中文:<br><strong>set meta-flag on</strong><br><strong>set input-meta on</strong></li>
<li>如果是想在终端编辑文件内容，可以通过Cydia安装一个vim（软件源<a href="http://apt.saurik.com）" target="_blank" rel="noopener">http://apt.saurik.com）</a><br><img src="/2018/10/23/3.SSH/VI IMproved.png" alt="VI IMproved"></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/17/2.SSH/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小马同学">
      <meta itemprop="description" content="iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小马同学的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/17/2.SSH/" itemprop="url">
                  SSH(上)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-17 22:05:00" itemprop="dateCreated datePublished" datetime="2018-10-17T22:05:00+08:00">2018-10-17</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-10-27 23:26:43" itemprop="dateModified" datetime="2018-10-27T23:26:43+08:00">2018-10-27</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/逆向实战/" itemprop="url" rel="index"><span itemprop="name">逆向实战</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>iOS | SSH | Objective-C</p>
<h2><span id="1mac远程登录到iphone">1.Mac远程登录到iPhone</span></h2><ul>
<li><strong>我们经常在Mac的终端上，通过敲一些命令行来完成一些操作</strong><br><img src="/2018/10/17/2.SSH/terminal.png" alt="terminal"></li>
<li><strong>iOS和Mac OS X都是基于Darwin（苹果的一个基于Unix的开源系统内核），所以iOS中同样支持终端的命令行操作</strong><br>1&gt; 在逆向工程中，我们经常会通过命令行来操纵iPhone</li>
<li><strong>为了能够让Mac终端中的命令行能作用在iPhone上，我们得让Mac和iPhone建立连接</strong><br>1&gt; 通过Mac远程登录到iPhone的方式建立连接<br><img src="/2018/10/17/2.SSH/Mac与iPhone连接.png" alt="Mac与iPhone连接"></li>
</ul>
<h2><span id="2ssh-openssh">2.SSH、OpenSSH</span></h2><p><strong>SSH：</strong><br>1&gt; Secure Shell的缩写，意为“安全外壳协议”，是一种可以为远程登录提供安全保障的协议<br>2&gt; 使用SSH，可以把所有传输的数据进行加密，“中间人”攻击方式就不可能实现，能防止DNS欺骗和IP欺骗<br><img src="/2018/10/17/2.SSH/SSH.png" alt="SSH"></p>
<hr>
<p><strong>OpenSSH：</strong><br>1&gt; 是SSH协议的免费开源实现<br>2&gt; 可以通过OpenSSH的方式让Mac远程登录到iPhone</p>
<hr>
<p><strong>使用OpenSSH远程登录：</strong></p>
<ul>
<li>在iPhone上通过Cydia安装OpenSSH工具（软件源<a href="http://apt.saurik.com）" target="_blank" rel="noopener">http://apt.saurik.com）</a><br><img src="/2018/10/17/2.SSH/OpenSSH-Cydia.png" alt="OpenSSH-Cydia"></li>
<li>OpenSSH的具体使用步骤可以查看Description中的描述<br><img src="/2018/10/17/2.SSH/OpenSSH-Description.png" alt="OpenSSH-Description"></li>
</ul>
<p><strong>使用OpenSSH远程登录 - 使用步骤:</strong></p>
<ul>
<li><strong>SSH是通过TCP协议通信，所以要确保Mac和iPhone在同一局域网下，比如连接着同一个WiFi</strong><br>1&gt; 在Mac的终端输入ssh 账户名@服务器主机地址<br>2&gt; 比如ssh <a href="mailto:root@192.168.31.26" target="_blank" rel="noopener">root@192.168.31.26</a>（这里的服务器是手机）<br>3&gt; 初始密码<strong>alpine</strong></li>
<li><strong>登录成功后就可以使用终端命令行操作iPhone</strong></li>
<li><strong>退出登录命令是exit</strong></li>
</ul>
<hr>
<p><strong>SSH的版本：</strong></p>
<ul>
<li><strong>SSH协议一共2个版本</strong><br>1&gt; SSH-1<br>2&gt; SSH-2</li>
<li><strong>现在用的比较多的是SSH-2，客户端和服务端版本要保持一致才能通信</strong></li>
<li><strong>查看SSH版本（查看配置文件的Protocol字段）</strong><br>1&gt; 客户端：/etc/ssh/ssh_config<br>2&gt; 服务端：/etc/ssh/sshd_config</li>
</ul>
<h2><span id="3root-mobile">3.root、mobile</span></h2><ul>
<li><strong>iOS下有2个常用账户：root、mobile</strong><br>1&gt; root：最高权限账户，$HOME是<strong>/var/root</strong><br>2&gt; mobile：普通权限账户，只能操作一些普通文件，不能操作系统级别的文件，$HOME是/var/mobile</li>
<li><strong>登录mobile用户：root mobile@服务器主机地址</strong></li>
<li><strong>root和mobile用户的初始登录密码都是alpine</strong><br><img src="/2018/10/17/2.SSH/iPhone-account.png" alt="iPhone-account"></li>
<li><strong>最好修改一下root和mobile用户的登录密码（登录root账户后，分别通过passwd、passwd mobile完成）</strong><br><img src="/2018/10/17/2.SSH/iPhone-account-password.png" alt="iPhone-account-password"></li>
</ul>
<h2><span id="4ssl-openssl">4.SSL、OpenSSL</span></h2><p><strong>很多人会将SSH、OpenSSH、SSL、OpenSSL搞混</strong></p>
<ul>
<li><strong>SSL</strong><br>1&gt; Secure Sockets Layer的缩写，是为网络通信提供安全及数据完整性的一种安全协议，在传输层对网络连接进行加密</li>
<li><strong>OpenSSL</strong><br>1&gt; SSL的开源实现<br>2&gt; 绝大部分HTTPS请求等价于：HTTP + OpenSSL</li>
<li><strong>OpenSSH的加密就是通过OpenSSL完成的</strong><br><img src="/2018/10/17/2.SSH/SSL、OpenSSL.png" alt="SSL、OpenSSL"></li>
</ul>
<h2><span id="5ssh的通信过程">5.SSH的通信过程</span></h2><p><strong>SSH的通信过程可以分为3大主要阶段：</strong><br>1&gt; 建立安全连接<br>2&gt; 客户端认证<br>3&gt; 数据传输</p>
<h2><span id="6建立安全连接">6.建立安全连接</span></h2><ul>
<li><strong>在建立安全连接过程中，服务器会提供自己的身份证明</strong><br><img src="/2018/10/17/2.SSH/建立安全连接.png" alt="建立安全连接"></li>
<li><strong>如果客户端并无服务器端的公钥信息，就会询问是否连接此服务器</strong><br><img src="/2018/10/17/2.SSH/SSH-Login.png" alt="SSH-Login"></li>
</ul>
<hr>
<p><strong>服务器身份信息变更：</strong></p>
<ul>
<li><strong>在建立安全连接过程中，可能会遇到以下错误信息：提醒服务器的身份信息发生了变更</strong><br><img src="/2018/10/17/2.SSH/服务器身份信息变更.png" alt="服务器身份信息变更"></li>
<li><strong>如果确定要连接此服务器，删除掉之前服务器的公钥信息就行</strong><br>1&gt; <strong>ssh-keygen -R 服务器IP地址</strong></li>
<li><strong>或者直接打开known_hosts文件删除服务器的公钥信息就行</strong><br>1&gt; <strong>vim ~/.ssh/known_hosts</strong></li>
</ul>
<h2><span id="7ssh的客户端认证方式">7.SSH的客户端认证方式</span></h2><ul>
<li><strong>SSH-2提供了2种常用的客户端认证方式</strong><br>1&gt; 基于密码的客户端认证<br>a.使用账号和密码即可认证<br>2&gt; 基于密钥的客户端认证<br>a.免密码认证<br>b.最安全的一种认证方式</li>
<li><strong>SSH-2默认会优先尝试“密钥认证”，如果认证失败，才会尝试“密码认证”</strong></li>
</ul>
<h2><span id="8ssh-基于密钥的客户端认证">8.SSH - 基于密钥的客户端认证</span></h2><p><img src="/2018/10/17/2.SSH/SSH-秘钥认证.png" alt="SSH-秘钥认证"></p>
<hr>
<ul>
<li>在客户端生成一对相关联的密钥（Key Pair）：一个公钥（Public Key），一个私钥（Private Key）<br>1&gt; <strong>ssh-keygen</strong><br>2&gt; 一路敲回车键（Enter）即可<br>3&gt; OpenSSH默认生成的是RSA密钥，可以通过-t参数指定密钥类型<br>4&gt; 生成的公钥：<strong>~/.ssh/id_rsa.pub</strong><br>5&gt; 生成的私钥：<strong>~/.ssh/id_rsa</strong></li>
<li>把客户端的公钥内容追加到服务器的授权文件（<strong>~/.ssh/authorized_keys</strong>）尾部<br>1&gt; ssh-copy-id root@服务器主机地址<br>2&gt; 需要输入root用户的登录密码<br>3&gt; <strong>ssh-copy-id</strong>会将客户端<strong>~/.ssh/id_rsa.pub</strong>的内容自动追加到服务器的<strong>~/.ssh/authorized_keys</strong>尾部</li>
<li>注意：由于是在~文件夹下操作，所以上述操作仅仅是解决了root用户的登录问题（不会影响mobile用户）</li>
</ul>
<hr>
<p><strong>可以使用ssh-copy-id将客户端的公钥内容自动追加到服务器的授权文件尾部，也可以手动操作：</strong></p>
<ul>
<li><strong>复制客户端的公钥到服务器某路径</strong><br>1&gt; <strong>scp ~/.ssh/id_rsa.pub root@服务器主机地址:~</strong><br>2&gt; scp是secure copy的缩写，是基于SSH登录进行安全的远程文件拷贝命令，把一个文件copy到远程另外一台主机上<br>3&gt; 上面的命令行将客户端的<strong>~/.ssh/id_rsa.pub</strong>拷贝到了服务器的~地址</li>
<li><strong>SSH登录服务器</strong><br>1&gt; <strong>ssh root@服务器主机地址</strong><br>2&gt; 需要输入root用户的登录密码</li>
<li><strong>在服务器创建.ssh文件夹</strong><br>1&gt; <strong>mkdir .ssh</strong></li>
<li><strong>追加公钥内容到授权文件尾部</strong><br>1&gt; <strong>cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</strong></li>
<li><strong>删除公钥</strong><br>1&gt; <strong>rm ~/id_rsa.pub</strong></li>
</ul>
<hr>
<p><strong>文件权限问题:</strong><br><strong>如果配置了免密码登录后，还是需要输入密码，需要在服务器端设置文件权限</strong><br>1&gt; chmod 755 ~<br>2&gt; chmod 755 ~/.ssh<br>3&gt; chmod 644 ~/.ssh/authorized_keys</p>
<h2><span id="922端口">9.22端口</span></h2><ul>
<li><strong>端口就是设备对外提供服务的窗口，每个端口都有个端口号（范围是0~65535，共2^16个）</strong></li>
<li><strong>有些端口号是保留的，已经规定了用途，比如</strong><br>1&gt; 21端口提供FTP服务<br>2&gt; 80端口提供HTTP服务<br>3&gt; 22端口提供SSH服务（可以查看/etc/ssh/sshd_config的Port字段）<br>4&gt; 更多保留端口号:<a href="https://baike.baidu.com/item/%E7%AB%AF%E5%8F%A3%E5%8F%B7/10883658#4_3" target="_blank" rel="noopener">https://baike.baidu.com/item/%E7%AB%AF%E5%8F%A3%E5%8F%B7/10883658#4_3</a></li>
<li><strong>iPhone默认是使用22端口进行SSH通信，采用的是TCP协议</strong><br><img src="/2018/10/17/2.SSH/22端口.png" alt="22端口"></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/09/1.越狱环境搭建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小马同学">
      <meta itemprop="description" content="iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小马同学的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/09/1.越狱环境搭建/" itemprop="url">
                  越狱环境搭建
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-09 08:00:00" itemprop="dateCreated datePublished" datetime="2018-10-09T08:00:00+08:00">2018-10-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-10-21 22:06:01" itemprop="dateModified" datetime="2018-10-21T22:06:01+08:00">2018-10-21</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/逆向实战/" itemprop="url" rel="index"><span itemprop="name">逆向实战</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>iOS | 越狱环境搭建 | Objective-C</p>
<h2><span id="1准备">1.准备</span></h2><ul>
<li><p>调试设备：<br>1&gt; 建议至少iPhone5s（因为从5s开始支持arm64架构）<br>2&gt; 或者至少是iPad Air、iPad mini2等支持arm64架构的设备</p>
</li>
<li><p>系统版本：<br>1&gt; 版本不能太高，最好保证能够完美越狱<br>2&gt; <a href="http://jailbreak.25pp.com/ios" target="_blank" rel="noopener">戳这里查看手机是否可以越狱</a><br>选择系统版本 -&gt;  选择设备 -&gt; 查看是否支持越狱（最好支持完美越狱）</p>
</li>
</ul>
<h2><span id="2ios-jailbreakios越狱">2.iOS Jailbreak（iOS越狱）</span></h2><p>利用iOS系统的漏洞，获取iOS系统的最高权限（Root），解开之前的各种限制（合法行为）</p>
<p><strong>优点：</strong></p>
<ul>
<li><p><strong>打造个性化、与众不同的iPhone</strong><br>1&gt; 自由安装各种实用的插件、主题、APP<br>2&gt; 修改系统APP的一些默认行为</p>
</li>
<li><p><strong>自由安装非AppSore来源的APP</strong><br>1&gt; “付费APP”秒变“免费APP”<br>2&gt; 未越狱iPhone安装APP的途径: AppStore、真机调试、通过证书打包签名ipa安装</p>
</li>
<li><p><strong>灵活管理文件系统，让iPhone可以像U盘那样灵活</strong></p>
</li>
<li><strong>给开发者提供了逆向工程的环境</strong></li>
</ul>
<p><strong>缺点：</strong> </p>
<ul>
<li><strong>不予保修</strong></li>
<li><strong>费电，越狱后的iOS系统会常驻一些进程，耗电速度约提升10%~20%</strong></li>
<li><strong>在新的iOS固件版本出来的时候，不能及时地进行更新</strong><br>1&gt; 每个新版本的固件，都会修复上一个版本的越狱漏洞，使越狱失效<br>2&gt; 如果需要保持越狱状态，要等待新的越狱程序发布时，才能升级相应的固件版本</li>
<li><strong>不再受iOS系统默认的安全保护，容易被恶意软件攻击，个人隐私有被窃取的风险</strong></li>
<li><strong>如果安装了不稳定的插件，容易让系统变得不稳定、变慢，甚至出现“白苹果”等问题</strong></li>
</ul>
<hr>
<p><strong>完美越狱：</strong></p>
<ul>
<li>越狱后的iPhone可以正常关机和重启</li>
</ul>
<p><strong>不完美越狱：</strong></p>
<ul>
<li>iPhone一旦关机后再开机时，屏幕就会一直停留在启动画面，也就是“白苹果”状态</li>
<li>或者能正常开机，但已经安装的破解软件都无法正常使用，需要将设备与PC连接后，使用软件进行引导才能使用</li>
<li>一般说来，在苹果发布新的iOS固件后，针对该固件的不完美越狱会先发布，随后完美越狱才可能发布</li>
<li>一般较新的系统版本，均为不完美越狱</li>
</ul>
<p><strong>越狱方法推荐：</strong><br><strong>PP助手：</strong><a href="http://jailbreak.25pp.com/" target="_blank" rel="noopener">http://jailbreak.25pp.com/</a></p>
<p><strong>如何判断是否越狱成功？</strong></p>
<ul>
<li><strong>桌面是否有Cydia</strong><br><img src="/2018/10/09/1.越狱环境搭建/Cydia.png" alt="桌面是否有Cydia"></li>
<li><strong>工具判断（eg. PP助手）</strong><br><img src="/2018/10/09/1.越狱环境搭建/PP助手-设备信息.png" alt="工具判断（比如PP助手）"></li>
</ul>
<h2><span id="3cydia">3.Cydia</span></h2><p><strong>1&gt; 越狱后的“App Store”</strong><br>可以在Cydia中安装各种第三方的软件（插件、补丁、APP）</p>
<p><strong>2&gt; 作者</strong><br>Jay Freeman (saurik)<br><img src="/2018/10/09/1.越狱环境搭建/Jay Freeman-saurik.png" alt="Cydia"></p>
<p><strong>Cydia安装软件的步骤:</strong><br><strong>1&gt;添加软件源（不同软件的软件源可能不同）</strong><br><img src="/2018/10/09/1.越狱环境搭建/添加软件源.png" alt="添加软件源"><br><strong>2&gt;进入软件源找到对应的软件，开始安装</strong><br><img src="/2018/10/09/1.越狱环境搭建/安装软件.png" alt="安装软件"></p>
<p><strong>SpringBoard</strong></p>
<ul>
<li>SpringBoard就是iOS的桌面</li>
<li>有时候通过Cydia安装完插件后，可能会出现以下界面<br><img src="/2018/10/09/1.越狱环境搭建/重启SpringBoard.png" alt="重启SpringBoard"></li>
</ul>
<h2><span id="4必备软件安装">4.必备软件安装</span></h2><p><strong>Apple File Conduit “2”</strong></p>
<ul>
<li><strong>Apple File Conduit “2”补丁的作用：</strong><br>1&gt; 可以访问整个iOS设备的文件系统<br>2&gt; 类似的补丁还有：afc2、afc2add</li>
<li><strong>软件源：</strong><br>1&gt; <a href="http://apt.saurik.com" target="_blank" rel="noopener">http://apt.saurik.com</a><br>2&gt; <a href="http://apt.25pp.com" target="_blank" rel="noopener">http://apt.25pp.com</a><br><img src="/2018/10/09/1.越狱环境搭建/Apple File Conduit &quot;2&quot;.png" alt="Apple File Conduit &quot;2&quot;"></li>
</ul>
<hr>
<p><strong>AppSync Unified</strong></p>
<ul>
<li><strong>AppSync Unified补丁的作用：</strong><br>1&gt; 可以绕过系统验证，随意安装、运行破解的ipa安装包</li>
<li><strong>软件源：</strong><br>1&gt; <a href="http://apt.25pp.com" target="_blank" rel="noopener">http://apt.25pp.com</a><br><img src="/2018/10/09/1.越狱环境搭建/AppSync Unified.png" alt="AppSync Unified"></li>
</ul>
<hr>
<p><strong>iFile</strong></p>
<ul>
<li><strong>iFile的作用：</strong><br>1&gt; 可以在iPhone上自由访问iOS文件系统<br>2&gt; 类似的还有Filza File Manager、File Browser</li>
<li><strong>软件源：</strong><br>1&gt; <a href="http://apt.thebigboss.org/repofiles/cydia" target="_blank" rel="noopener">http://apt.thebigboss.org/repofiles/cydia</a><br><img src="/2018/10/09/1.越狱环境搭建/iFile.png" alt="iFile"></li>
</ul>
<hr>
<p><strong>PP助手</strong></p>
<ul>
<li><strong>PP助手的作用：</strong><br>1&gt; 可以利用PP助手自由安装海量APP</li>
<li><strong>软件源：</strong><br>1&gt; <a href="http://apt.25pp.com/" target="_blank" rel="noopener">http://apt.25pp.com/</a><br><img src="/2018/10/09/1.越狱环境搭建/PP助手.png" alt="iFile"></li>
</ul>
<hr>
<p><strong>Mac必备：</strong></p>
<ul>
<li><p><strong>iFunBox</strong><br>1&gt; 管理文件系统</p>
</li>
<li><p><strong>PP助手</strong><br>1&gt; 自由安装海量APP<br>2&gt; 卸载APP<br>3&gt; 备份APP为ipa安装包（iOS9开始，不再支持备份APP）</p>
</li>
</ul>
<hr>
<p><strong>建议安装顺序：</strong><br><img src="/2018/10/09/1.越狱环境搭建/建议安装顺序.png" alt="建议安装顺序"></p>
<hr>
<p><strong>安装包</strong></p>
<ul>
<li><strong>通常情况下</strong><br>1&gt; 通过Cydia安装的安装包是deb格式的（结合软件包管理工具apt）<br>2&gt; 通过PP助手安装的安装包是ipa格式的</li>
<li><strong>如果通过Cydia源安装deb失败</strong><br>1&gt; 可以先从网上下载deb格式的安装包<br>2&gt; 然后打开 iFunBox -&gt; 文件系统，将deb安装包放到/var/root/Media/Cydia/AutoInstall<br>3&gt; 重启手机，Cydia就会自动安装deb</li>
<li><strong>比如，下图是iFile 2.2.0-1所需的deb安装包</strong><br><a href="/download/1.越狱环境搭建/iFile2.2.0-1.zip">点击下载iFile安装包</a><br><img src="/2018/10/09/1.越狱环境搭建/iFile安装包安装.png" alt="iFile安装包安装"></li>
</ul>
<h2><span id="5如何在ios代码中判断设备是否越狱">5.如何在iOS代码中判断设备是否越狱？</span></h2><p><strong>1&gt; 针对不同iOS版本的判断方法可能不一样</strong><br><strong>2&gt; 最简单的一种方法：判断手机上是否安装了Cydia</strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:<span class="string">@"/Applications/Cydia.app"</span>];</span><br></pre></td></tr></table></figure></p>
<p>当然，不同系统版本判断方法可能不太一样，仅用这个方法判断是不严谨的，如果需要更完善的方法的同学们可自行谷歌</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/03/LLVM-Clang 插件开发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小马同学">
      <meta itemprop="description" content="iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小马同学的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/03/LLVM-Clang 插件开发/" itemprop="url">
                  LLVM-Clang 插件开发
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-03 13:59:05 / 修改时间：21:13:34" itemprop="dateCreated datePublished" datetime="2018-10-03T13:59:05+08:00">2018-10-03</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编译原理/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>iOS | LLVM | Objective-C</p>
<h1><span id="clang-插件开发-准备">Clang 插件开发-准备</span></h1><p><strong>$ cd LLVM_ALL/llvm/tools/clang/tools</strong><br><strong>$ mkdir Your_Plugin_Dir_Name</strong><br>新建文件夹（自己的插件，eg. 我的文件夹命名为 mz-plugin，后面以我自己的文件目录讲解，各位同学在实践的时候请注意替换为自己的文件夹目录）</p>
<p>在 <strong>clang/tools</strong> 目录下 <strong>CMakeLists.txt</strong> 文件最下方添加我们自己的插件目录: <strong>add_clang_subdirectory(mz-plugin)</strong>，这样，clang 在编译时就会加载我们插件目录下的插件</p>
<p><strong>$ cd mz-plugin</strong><br><strong>$ touch MZPlugin.cpp</strong><br><strong>$ touch CMakeLists.txt</strong></p>
<p>编辑 <strong>CMakeLists.txt</strong>，添加下面这行：<br><strong>add_llvm_loadable_module(MZPlugin MZPlugin.cpp)</strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果有多个 cpp 文件，可以如下：</span></span><br><span class="line">add_llvm_loadable_module(MZPlugin </span><br><span class="line">MZPlugin1.cpp</span><br><span class="line">MZPlugin2.cpp</span><br><span class="line">MZPlugin3.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h1><span id="编写插件">编写插件</span></h1><p>编写 C++ 文件，当然是用 IDE 方便了，在 <strong>llvm_xcode</strong> 目录下执行 <strong>cmake -G Xcode ../llvm</strong> 生成的模板工程，首次打开选择 <strong>Automatically Create Schemes</strong> 方式创建scheme<br><img src="/2018/10/03/LLVM-Clang 插件开发/Automatically Create Schemes.png" alt="Automatically Create Schemes"></p>
<p>找到我们自己的插件 cpp 文件 <strong>Loadable modules/MZPlugin/MZPlugin.cpp</strong>，编写插件：<br><img src="/2018/10/03/LLVM-Clang 插件开发/插件cpp文件.png" alt="插件cpp文件"></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#include <span class="meta-string">"clang/AST/AST.h"</span></span></span><br><span class="line"><span class="meta">#include <span class="meta-string">"clang/AST/ASTConsumer.h"</span></span></span><br><span class="line"><span class="meta">#include <span class="meta-string">"clang/ASTMatchers/ASTMatchers.h"</span></span></span><br><span class="line"><span class="meta">#include <span class="meta-string">"clang/ASTMatchers/ASTMatchFinder.h"</span></span></span><br><span class="line"><span class="meta">#include <span class="meta-string">"clang/Frontend/CompilerInstance.h"</span></span></span><br><span class="line"><span class="meta">#include <span class="meta-string">"clang/Frontend/FrontendPluginRegistry.h"</span></span></span><br><span class="line"></span><br><span class="line">using namespace clang;</span><br><span class="line">using namespace std;</span><br><span class="line">using namespace llvm;</span><br><span class="line"></span><br><span class="line">namespace MZPlugin &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> MZConsumer : public ASTConsumer &#123;</span><br><span class="line">    public:</span><br><span class="line">    <span class="comment">// 重写 HandleTranslationUnit，在每编译完成一个语法树时都会调用此方法</span></span><br><span class="line">    <span class="keyword">void</span> HandleTranslationUnit(ASTContext &amp;Ctx) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">"MZPlugin-HandlerTranslationUnit，编译完成一个语法树"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 PluginASTAction，重写两个方法</span></span><br><span class="line"><span class="keyword">class</span> MZAction: public PluginASTAction &#123;</span><br><span class="line">    public:</span><br><span class="line">    unique_ptr&lt;ASTConsumer&gt; CreateASTConsumer(CompilerInstance &amp;ci, StringRef isFile) &#123;</span><br><span class="line">        <span class="keyword">return</span> unique_ptr&lt;MZConsumer&gt; (new MZConsumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> ParseArgs(<span class="keyword">const</span> CompilerInstance &amp;ci, <span class="keyword">const</span> vector&lt;string&gt; &amp;args) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">注册插件</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.static clang::FrontendPluginRegistry::Add&lt;MZPlugin::MZAction&gt;</span></span><br><span class="line"><span class="comment">2.泛型 声明 Add 类型，指定 MZPlugin 的 MZAction</span></span><br><span class="line"><span class="comment">3.官方给的示例用的 X 就按官方的来吧</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@param "MZPlugin" 插件名称</span></span><br><span class="line"><span class="comment">@param clang-plugin." 插件描述</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> FrontendPluginRegistry::Add&lt;MZPlugin::MZAction&gt;</span><br><span class="line">X(<span class="string">"MZPlugin"</span>, <span class="string">"The MZPlugin is my first clang-plugin."</span>);</span><br></pre></td></tr></table></figure>
<h1><span id="编译插件">编译插件</span></h1><p>编写完成之后，选择我们的插件 <strong>target</strong>，编译出 .dylib 插件文件：<br><img src="/2018/10/03/LLVM-Clang 插件开发/编译插件.png" alt="编译插件"></p>
<p>编译成功之后，会在 <strong>llvm_xcode/Debug/lib/</strong> 目录下生成 <strong>MZPlugin.dylib</strong>文件</p>
<h1><span id="使用插件">使用插件</span></h1><p>在Xcode 项目中指定加载插件动态库：Build Settings -&gt; Other C Flags:<br><strong>-Xclang -load -Xclang 动态库全路径 -Xclang -add-plugin -Xclang 插件名称</strong></p>
<p>eg.-Xclang -load -Xclang /Users/<strong>username</strong>/Desktop/项目/LLVM_ALL<br>/llvm_xcode/Debug/lib/MZPlugin.dylib -Xclang -add-plugin -Xclang MZPlugin</p>
<p><img src="/2018/10/03/LLVM-Clang 插件开发/Other C Flags.png" alt="Other C Flags"></p>
<p>已经安耐不住激动的心情了么，编译项目，结果会报错，因为 Xcode  Build Settings <strong>Compiler for C/C++/Objective</strong> 默认编译器使用的是 <strong>Default compiler（Apple LLVM 9.0）</strong>，不让我们选择我们自己的编译器，我们还需要最后一步，Hack Xcode，然后才能修改默认的编译器</p>
<h1><span id="hack-xcode">Hack Xcode</span></h1><p>下载 <a href="/download/插件开发/XcodeHacking.zip"><strong>XcodeHacking.zip</strong></a>，解压，修改 <strong>HackedClang.xcplugin/Contents/Resources/HackedClang.xcspec</strong>，将 ExecPath 位置 替换为我们刚才用 ninja 编译好的 clang 的全路径<br>eg.  /Users/<strong>username</strong>/Desktop/项目/LLVM_ALL/llvm_release/bin/clang<br><img src="/2018/10/03/LLVM-Clang 插件开发/HackedClang.xcspec.png" alt="HackedClang.xcspec"></p>
<p>然后执行下面两行指令将这两个文件移至 Xcode 包中：<br><strong>$ sudo mv HackedClang.xcplugin <code>xcode-select -print-path</code>/../PlugIns<br>/Xcode3Core.ideplugin/Contents/SharedSupport/Developer/Library/Xcode/Plug-ins</strong></p>
<p><strong>$ sudo mv HackedBuildSystem.xcspec <code>xcode-select -print-path</code>/Platforms<br>/iPhoneSimulator.platform/Developer/Library/Xcode/Specifications</strong></p>
<p>完成之后，重启 Xcode，这时，我们就可以修改 Xcode 默认的编译器了<br><img src="/2018/10/03/LLVM-Clang 插件开发/Compiler.png" alt="Compiler for C/C++/Objective"></p>
<p>选择 <strong>Clang LLVM Trunk</strong>，然后进行编译，这时候我们观察下便以信息，会发现，刚才我们输出我们在 <strong>HandleTranslationUnit</strong> 方法中的信息已经成功输出<br><img src="/2018/10/03/LLVM-Clang 插件开发/success.png" alt="success"></p>
<h2><span id="总结">总结</span></h2><p>至此我们已经完成了一个简单的插件开发，如果需要开发更牛逼的功能，我们还需要对编译原理、语义分析等进行更深入的了解，感兴趣的童鞋可以深入研究</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/24/编译器王者-LLVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小马同学">
      <meta itemprop="description" content="iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小马同学的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/24/编译器王者-LLVM/" itemprop="url">
                  编译器王者-LLVM
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-24 19:22:19" itemprop="dateCreated datePublished" datetime="2018-09-24T19:22:19+08:00">2018-09-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-10-03 17:26:10" itemprop="dateModified" datetime="2018-10-03T17:26:10+08:00">2018-10-03</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编译原理/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>iOS | LLVM | Objective-C</p>
<h1><span id="llvm-是什么">LLVM 是什么？</span></h1><p><img src="/2018/09/24/编译器王者-LLVM/LLVM_Logo.svg" alt="LLVM-logo"></p>
<blockquote>
<p>The LLVM Project is a collection of modular and reusable compiler and toolchain technologies.<br>官网：<a href="https://llvm.org/" target="_blank" rel="noopener">https://llvm.org/</a></p>
</blockquote>
<p>LLVM 项目是模块化、可重用的编译器以及工具链技术的集合，美国计算机协会（ACM）将其2012年软件系统奖项颁给了LLVM，之前曾获得此奖项的软件和技术包括：Java、Apache、Mosaic、the World Wide Web、Smalltalk、UNIX、Eclipse等</p>
<p>创始人： Chris Lattner，亦是Swift之父</p>
<blockquote>
<ul>
<li>有些文章把 LLVM 当做 Low Level Virtual Machine（低级虚拟机）的缩写简称，官方描述如下:</li>
<li>The name “LLVM” itself is not an acronym; it is the full name of the project.<br>“LLVM” 不是首字母缩略词，它是项目的全称</li>
</ul>
</blockquote>
<h1><span id="传统的编译器架构">传统的编译器架构</span></h1><p><img src="/2018/09/24/编译器王者-LLVM/传统编译器架构.png" alt="传统编译器架构"><br>传统编译器架构：</p>
<ul>
<li>Frontend：前端（词法分析、语法分析、语义分析、生成中间代码）</li>
<li>Optimizer：优化器（中间代码优化）</li>
<li>Backend：后端（生成对应平台、设备、架构机器码）</li>
</ul>
<h1><span id="llvm架构">LLVM架构</span></h1><p><img src="/2018/09/24/编译器王者-LLVM/LLVM编译器架构.png" alt="传统编译器架构"><br>不同的前端后端使用统一的中间代码 LLVM Intermediate Representation（LLVM IR）</p>
<p>统一中间代码的优点：<br>1&gt; 如果需要支持一种新的编程语言，只需要实现一个新的前端<br>2&gt; 如果需要支持一种新的硬件设备，只需要实现一个新的后端<br>3&gt; 优化阶段是一个通用的阶段，它针对的是统一的 LLVM IR，不论是支持新的编程语言，还是支持新的硬件设备，都不需要对优化阶段做修改</p>
<p>相比之下，GCC 的前端和后端没有分的太开，前端后端耦合在一起。所以 GCC 为了支持一门新的语言，或者支持一个新的目标平台，就变得非常困难</p>
<p>LLVM 现在被作为实现各种静态和运行时编译语言的通用基础结构（GCC家族、JAVA、.NET、Python、Ruby、Scheme、Haskell等）</p>
<h1><span id="clang">Clang</span></h1><p>1&gt; 什么是 Clang ?<br>Clang 是 LLVM 项目的一个子项目，基于 LLVM 架构 C/C++/Objective-C 的编译器前端</p>
<p>官网：<a href="http://clang.llvm.org/" target="_blank" rel="noopener">http://clang.llvm.org/</a></p>
<p>2&gt; 相比于 GCC，Clang 具有如下有点：<br><strong>编译速度快</strong>：在某些平台上，Clang 的编译速度显著的快过 GCC（Debug 模式下编译 OC 速度比 GCC 快 3 倍）<br><strong>占用内存小</strong>：Clang 生成的 AST(语法树) 所占用的内存是 GCC 的五分之一左右<br><strong>模块化设计</strong>：Clang 采用基于库的模块化设计，易于 IDE 继承及其他用途的作用<br><strong>诊断信息可读性强</strong>：在编译过程中，Clang 创建并保留了大量详细的元数据（metadata），有利于调试和错误定位<br><strong>设计清晰简单</strong>，容易理解，易于扩展增强</p>
<h1><span id="clang-与-llvm">Clang 与 LLVM</span></h1><p><img src="/2018/09/24/编译器王者-LLVM/Clang-LLVM_1.jpg" alt="传统编译器架构"><br><strong>广义的 LLVM</strong>：整个 LLVM 架构<br><strong>狭义的 LLVM</strong>：LLVM 后端（代码优化、目标代码生成等）</p>
<p><img src="/2018/09/24/编译器王者-LLVM/Clang-LLVM_2.png" alt="传统编译器架构"></p>
<h1><span id="oc源文件的编译过程">OC源文件的编译过程</span></h1><p><strong>命令行查看编译的过程</strong>：$ clang -ccc-print-phases main.m<br><img src="/2018/09/24/编译器王者-LLVM/OC源文件编译过程1.png" alt="OC源文件编译器过程1"><br>输入 main.m =&gt; 预处理器，预处理（include、import、宏定义…），输出 cpp 文件 =&gt; compiler 编译成中间代码 ir =&gt; 后端，目标代码 =&gt; 链接动态库等 =&gt; 适合 ** 架构的代码</p>
<p><strong>查看preprocessor（预处理）的结果</strong>：$ clang -E main.m</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define AGE 30</span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b + AGE;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/09/24/编译器王者-LLVM/OC源文件编译过程1.png" alt="OC源文件编译过程2"><br>执行上面的命令行之后，发现预处理器将 &lt;stdio.h&gt; 中代码引了进来，而且将 AGE 宏 也替换成了 30</p>
<h1><span id="词法分析">词法分析</span></h1><p><strong>词法分析，生成 Token</strong>：$ clang -fmodules -E -Xclang -dump-tokens main.m<br><img src="/2018/09/24/编译器王者-LLVM/词法分析.png" alt="OC源文件编译过程2"><br>将代码中每个部分生成 token，’int’、’main’、’(‘、’int’、’argc’ …，一遍后面分析，Loc=<a href="main.m:13:9" target="_blank" rel="noopener">main.m:13:9</a>表示 main.m 13 行第 9 个字符</p>
<h1><span id="语法树-ast">语法树 - AST</span></h1><p><strong>语法分析，生成语法树（AST，Abstract Syntax Tree）</strong>：$ clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</p>
<p>词法分析之后将 Token 拼接、联系起来，生成语法树：<br><img src="/2018/09/24/编译器王者-LLVM/语法树.png" alt="OC源文件编译过程2"></p>
<h1><span id="llvm-ir">LLVM IR</span></h1><p>LLVM IR 有3中表示形式（但本质是等价的，就好比水可以有气体、液体、固体3中形态）</p>
<p><strong>1&gt;text</strong>：便于阅读的文本格式，类似于汇编语言，扩展名 .ll，$ clang -S -emit-llvm main.m<br><strong>2&gt;memory</strong>：内存格式<br><strong>3&gt;bitcode</strong>：二进制格式，扩展名 .bc，$ clang -c -emit-llvm main.m</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> test(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b - <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码生成 text 格式中间代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">define <span class="keyword">void</span> @test(i32, i32) <span class="meta">#0 &#123;</span></span><br><span class="line">    <span class="comment">// 定义一个局部变量 int a </span></span><br><span class="line">    %<span class="number">3</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">    <span class="comment">// 定义一个局部变量 int b</span></span><br><span class="line">    %<span class="number">4</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">    <span class="comment">// 定义一个局部变量 int c</span></span><br><span class="line">    %<span class="number">5</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">    <span class="comment">// 将 0（第一个参数）的值赋给 3，即 a</span></span><br><span class="line">    store i32 %<span class="number">0</span>, i32* %<span class="number">3</span>, align <span class="number">4</span></span><br><span class="line">    <span class="comment">// 将 1（第二个参数）的值赋给 4，即 b</span></span><br><span class="line">    store i32 %<span class="number">1</span>, i32* %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">    <span class="comment">// 读取 3 的值给 6，即 a</span></span><br><span class="line">    %<span class="number">6</span> = load i32, i32* %<span class="number">3</span>, align <span class="number">4</span></span><br><span class="line">    <span class="comment">// 读取 4 的值给 7，即 b</span></span><br><span class="line">    %<span class="number">7</span> = load i32, i32* %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">    <span class="comment">// 6 + 7，即 a + b，给 8</span></span><br><span class="line">    %<span class="number">8</span> = add nsw i32 %<span class="number">6</span>, %<span class="number">7</span></span><br><span class="line">    <span class="comment">// 8 - 3，即 a + b - 3</span></span><br><span class="line">    %<span class="number">9</span> = sub nsw i32 %<span class="number">8</span>, <span class="number">3</span></span><br><span class="line">    <span class="comment">// 将 a + b - 3 的结果给 5，即 c，即 c = a + b - 3</span></span><br><span class="line">    store i32 %<span class="number">9</span>, i32* %<span class="number">5</span>, align <span class="number">4</span></span><br><span class="line">    ret <span class="keyword">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>IR 基本语法:</strong><br>1&gt; 注释以分号<strong> ;</strong> 开头<br>2&gt; 全局标识符以<strong>@</strong>开头，局部标识符以<strong>%</strong>开头<br>3&gt; <strong>alloca</strong>，在当前函数栈帧中分配内存<br>4&gt; <strong>i32</strong>，32bit，4个字节的意思<br>5&gt; <strong>align</strong>，内存对齐<br>6&gt; <strong>store</strong>，写入数据<br>7&gt; <strong>load</strong>，读取数据</p>
<p>官方语法参考：<br><a href="https://llvm.org/docs/LangRef.html" target="_blank" rel="noopener">https://llvm.org/docs/LangRef.html</a></p>
<hr>
<p>上面带大家简单熟悉了下 LLVM，感兴趣的童鞋可以进入官网自行深入研究。光了解是不是有点无趣呢，接下来，我们来开发一个我们自己的编译器插件</p>
<h1><span id="llvm-clang-源码下载">LLVM、Clang 源码下载</span></h1><p>下载LLVM<br>\$ <a href="https://git.llvm.org/git/llvm.git/" target="_blank" rel="noopener">https://git.llvm.org/git/llvm.git/</a><br>大小 661.3 M，仅供参考</p>
<p>下载clang<br>\$ cd llvm/tools<br>$ git clone <a href="https://git.llvm.org/git/clang.git/" target="_blank" rel="noopener">https://git.llvm.org/git/clang.git/</a><br>大小 242.9 M，仅供参考</p>
<h1><span id="源码编译">源码编译</span></h1><p>我们在终端可以敲 clang 命令，是因为在 Xcode …/XcodeDefault.xctoolchain/user/bin目录下已经安装了Clang，并且MAC 默认用的是 Xcode 内置的 Clang。既然我们要开发自己的编译器插件，所以在源码下载完成之后，我们需要编译我们自己的 Clang</p>
<p><strong>安装 cmake 和 ninja</strong>（先安装brew，<a href="https://brew.sh" target="_blank" rel="noopener">https://brew.sh</a>）<br>1&gt; $ brew install cmake<br>2&gt; $ brew install ninja</p>
<p><strong>注</strong>：ninja 如果安装失败，可以直接从 github 获取 release 版放入 <strong>/usr/local/bin</strong>中，<a href="https://github.com/ninja-build/ninja/releases" target="_blank" rel="noopener">https://github.com/ninja-build/ninja/releases</a></p>
<hr>
<p>在LLVM源码统计目录下新建一个 <strong>llvm_build</strong>目录（最终会在 <strong>llvm_build</strong> 目录下生成 <strong>build.ninja</strong>）</p>
<p>/LLVM_ALL/llvm<br>/LLVM_ALL/llvm_build<br>/LLVM_ALL/llvm_release<br>/LLVM_ALL/llvm_xcode</p>
<p><strong>$ cd llvm_build</strong><br><strong>$ cmake -G Ninja ../llvm</strong>(指定 llvm 源码位置，会将 llvm 源码在llvm_build 目录下生成 ninja 的模板，注：llvm 路径需根据自己的 llvm 目录相对于 llvm_build 的位置) <strong>成功的标识</strong>：llvm_build 目录下生成 build.ninja 文件</p>
<p><strong>指定LLVM编译目标路径：</strong><br><strong>$ cmake -G Ninja ../llvm -DCMAKE_INSTALL_PREFIX=LLVM的安装路径</strong><br>(eg.)  $ cmake -G Ninja ../llvm -DCMAKE_INSTALL_PREFIX=/users/<em>username</em>/Desktop/项目/LLVM_ALL/llvm_release/</p>
<p>更多 cmake 相关选项，可以参考：<a href="https://llvm.org/docs/CMake.html" target="_blank" rel="noopener">https://llvm.org/docs/CMake.html</a></p>
<hr>
<p>依次执行编译、安装指令<br><strong>$ ninja</strong><br>编译完毕后， <strong>llvm_build</strong> 目录大概 21.61 G（仅供参考）<br><strong>$ ninja install</strong><br>安装完毕后，安装目录大概 12.21 G（仅供参考）</p>
<hr>
<p>生成 Xcode 模板工程，使用 Xcode 进行编译<br><strong>$ cd llvm_xcode</strong><br><strong>$ cmake -G Xcode ../llvm</strong></p>
<h1><span id="应用与实践">应用与实践</span></h1><p>1&gt; libclang、libTooling<br>官方参考：<a href="https://clang.llvm.org/docs/Tooling.html" target="_blank" rel="noopener">https://clang.llvm.org/docs/Tooling.html</a><br>应用：<strong>语法树分析</strong>、<strong>语言转换</strong>等</p>
<p>2&gt; Clang 插件开发<br>官方参考：<br><a href="https://clang.llvm.org/docs/" target="_blank" rel="noopener">https://clang.llvm.org/docs/</a><br><a href="https://clang.llvm.org/docs/ClangPlugins.html" target="_blank" rel="noopener">https://clang.llvm.org/docs/ClangPlugins.html</a><br><a href="https://clang.llvm.org/docs/ExternalClangExamples.html" target="_blank" rel="noopener">https://clang.llvm.org/docs/ExternalClangExamples.html</a><br><a href="https://clang.llvm.org/docs/RAVFrontendAction.html" target="_blank" rel="noopener">https://clang.llvm.org/docs/RAVFrontendAction.html</a><br>应用：<strong>代码检查（命名规范、代码规范）</strong>等</p>
<p>3&gt; Pass开发<br>官方参考：<a href="http://llvm.org/docs/WritingAnLLVMPass.html" target="_blank" rel="noopener">http://llvm.org/docs/WritingAnLLVMPass.html</a><br>应用：<strong>代码优化</strong>、<strong>代码混淆</strong>等</p>
<p>4&gt; 开发新的编程语言<br><a href="https://llvm-tutorial-cn.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://llvm-tutorial-cn.readthedocs.io/en/latest/index.html</a><br><a href="https://kaleidoscope-llvm-tutorial-zh-cn.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">https://kaleidoscope-llvm-tutorial-zh-cn.readthedocs.io/zh_CN/latest</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/18/Category/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小马同学">
      <meta itemprop="description" content="iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小马同学的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/18/Category/" itemprop="url">
                  Category
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-18 23:08:48" itemprop="dateCreated datePublished" datetime="2018-09-18T23:08:48+08:00">2018-09-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-09-24 22:26:38" itemprop="dateModified" datetime="2018-09-24T22:26:38+08:00">2018-09-24</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS底层原理/" itemprop="url" rel="index"><span itemprop="name">iOS底层原理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>iOS | Category | Objective-C</p>
<p>Category的实现原理？Category和Class Extension的区别是什么？Category中的load方法时什么时候调用的？如何给分类添加属性？</p>
<hr>
<p>通过前面章节，我们有学习到OC实例方法存储在class对象里面，类方法存储在meta-class里面，那么分类里面方法呢，难道是一个新的对象来进行存储么？</p>
<p>答案肯定是否，<strong>class对象、meta-class对象在内存中只会存在一份，分类里面的方法会合并到class对象、meta-class中</strong>。</p>
<h2><span id="1category的实现原理">1.Category的实现原理</span></h2><p>Category内方法是什么时候合并到class、meta-class对象中的，是在编译阶段么？</p>
<p>并不是，是在程序运行时通过runtime机制动态将分类的方法合并到class、meta-class对象中。下面来通过探索源码来进行分析验证。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">Test_A</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)testA;</span><br><span class="line">- (<span class="keyword">void</span>)testA;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">Test_A</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)testA &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)testA &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>通过clang编译器将 Person+Test_A.m 文件转成cpp文件，搜索 struct _category_t {<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> _category_t &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"><span class="keyword">struct</span> _class_t *cls;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">struct</span> _method_list_t *instance_methods;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">struct</span> _method_list_t *class_methods;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">struct</span> _protocol_list_t *protocols;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">struct</span> _prop_list_t *properties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Person+Test_A这个分类在编译完，转成上面这种结构，Test_A分类里面的方法、协议、属性信息也是存储在这个结构体中。每编写一个分类，就相当于一个 struct _category_t 类型的结构体，在程序运行时，通过runtime机制动态的将这个结构体内部的方法、协议等合并到类对象中。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/11/KVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小马同学">
      <meta itemprop="description" content="iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小马同学的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/11/KVC/" itemprop="url">
                  KVC
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-11 23:37:08" itemprop="dateCreated datePublished" datetime="2018-09-11T23:37:08+08:00">2018-09-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-09-24 22:26:28" itemprop="dateModified" datetime="2018-09-24T22:26:28+08:00">2018-09-24</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS底层原理/" itemprop="url" rel="index"><span itemprop="name">iOS底层原理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>iOS | KVC | Objective-C</p>
<p>通过KVC修改属性会不会触发KVO，KVC底层实现是什么样子？</p>
<h2><span id="1kvc">1.KVC</span></h2><p>KVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问某个属性</p>
<p>常见API:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line">- (<span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure></p>
<h2><span id="2通过kvc修改属性会触发kvo么">2.通过KVC修改属性会触发KVO么</span></h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Observer</span></span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, change);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observer *observer = [[Observer alloc] init];</span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line"></span><br><span class="line">[person addObserver:observer forKeyPath:<span class="string">@"age"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span>|<span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">[person setValue:@<span class="number">20</span> forKey:<span class="string">@"age"</span>];</span><br><span class="line"></span><br><span class="line">[person removeObserver:observer forKeyPath:<span class="string">@"age"</span>];</span><br></pre></td></tr></table></figure>
<p>通过控制台输出，发现是可以触发KVO的</p>
<h2><span id="3setvalueforkey">3.setValue:forKey</span></h2><p><img src="/2018/09/11/KVC/setValueForKey.png" alt="setValue:forKey:"><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[person setValue:@<span class="number">20</span> forKey:<span class="string">@"age"</span>];</span><br></pre></td></tr></table></figure></p>
<p>上面这行代码相当于下面这几行，在对属性赋值的时候系统内部会自动调用 willChangeValueForKey 和 didChangeValueForKey，所以会触发 KVO，可以重写这两个方法进行验证。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[person willChangeValueForKey:<span class="string">@"age"</span>];</span><br><span class="line">person-&gt;_age = <span class="number">20</span>;</span><br><span class="line">[person didChangeValueForKey:<span class="string">@"key"</span>];</span><br></pre></td></tr></table></figure></p>
<h2><span id="4valueforkey">4.valueForKey</span></h2><p><img src="/2018/09/11/KVC/setValueForKey.png" alt="valueForKey:"></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/06/iOS中的线程同步方案-锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小马同学">
      <meta itemprop="description" content="iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小马同学的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/iOS中的线程同步方案-锁/" itemprop="url">
                  iOS中的线程同步方案（锁）、读写安全方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-06 08:42:11" itemprop="dateCreated datePublished" datetime="2018-09-06T08:42:11+08:00">2018-09-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-09-11 23:15:30" itemprop="dateModified" datetime="2018-09-11T23:15:30+08:00">2018-09-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS底层原理/" itemprop="url" rel="index"><span itemprop="name">iOS底层原理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="ios中的线程同步方案">iOS中的线程同步方案</span></h1><ul>
<li>OSSpinLock</li>
<li>os_unfair_lock</li>
<li>pthread_mutex</li>
<li>dispatch_semaphore</li>
<li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li>
<li>NSLock</li>
<li>NSRecursiveLock</li>
<li>NSCondition</li>
<li>NSConditionLock</li>
<li>@synchronized</li>
</ul>
<h1><span id="1osspinlock">1.OSSpinLock</span></h1><p>1&gt; OSSpinLock叫做“自旋锁”，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源；High-level lock，高级锁，等不到锁时忙等，不会休眠<br>2&gt; 目前已经不再安全，可能会出现优先级反转问题<br>3&gt; 如果等待锁的优先级较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁<br>4&gt; 需要导入头文件 #import <strong>&lt;libkern/OSAtomic.h&gt;</strong></p>
<p><strong>自旋锁优先级反转：</strong>有两个线程，thread1（高优先级）、thread2（低优先级），thread2先进行加锁操作，CPU切换调度，thread1进入，发现已经被锁，进入自旋状态。由于thread1优先级比thread2高出很多，CPU接下来可能一直调度thread1，处于自旋状态，相当于一直执行不到thread2的解锁操作，造成优先级反转现象</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化锁</span></span><br><span class="line">OSSpinLock lock = OS_SPINLOCK_INIT;</span><br><span class="line"><span class="comment">// 尝试加锁（如果需要等待就不加锁，直接返回false；如果不需要等待就加锁，返回true）</span></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">OSSpinLockLock(&amp;lock);</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">OSSpinLockUnlock(&amp;lock);</span><br></pre></td></tr></table></figure>
<p>OSSpinLock是性能最高的锁，因为加锁操作耗时较短的话，忙等一会儿直接继续执行了；反之休眠的话唤醒也是需要耗性能的。但是现在已经不再安全了，所以苹果不建议我们再继续使用OSSpinLock了</p>
<p>验证<strong>OSSpinLock自旋锁忙等</strong>：<br>Xcode -&gt; Debug Workflow -&gt; Always show Disassembly</p>
<p>step:：代码级别一行一行走<br>stepi：汇编指令一行一行走，简称 si<br>nexti：汇编指令一行一行走，但是如果遇到函数调用不会进去，会直接跳过</p>
<p>我们通过 si 指令，一行一行走，进入 OSSpinLockLock 函数，继续，进入 _OSSpinLockLockSlow 函数，这个时候要注意了：会一直在一块儿内存地址代码之间重复执行，这种就是典型的while循环，自旋锁，只有锁被放开之后才会往下继续执行</p>
<h1><span id="2os_unfair_lock_lock">2.os_unfair_lock_lock</span></h1><p>1&gt; os_unfair_lock用于取代不安全的OSSpinLock，从iOS10开始支持<br>2&gt; 从底层调用看，等待os_unfair_lock锁的线程会处于休眠状态，并非忙等；Low-level lock,低级锁，等不到锁时休眠<br>3&gt; 需要导入头文件 #import <strong>&lt;os/lock.h&gt;</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">os_unfair_lock lock = OS_UNFAIR_LOCK_INIT;</span><br><span class="line"><span class="comment">// 尝试加锁</span></span><br><span class="line">os_unfair_lock_trylock(&amp;lock);</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">os_unfair_lock_lock(&amp;lock);</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">os_unfair_lock_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>
<p>验证 <strong>os_unfair_lock_lock 非忙等</strong>：<br>os_unfair_lock_lock -&gt; _os_unfair_lock_lock_slow -&gt; __ulock_wait，进入之后，发现断点过着过着、到syscall时直接过去了，直接休眠了，这也说明os_unfair_lock_lock线程等待时并非忙等，而是休眠了</p>
<h1><span id="3-pthread_mutex">3. pthread_mutex</span></h1><p>1&gt; mutex叫做“互斥锁”，等待锁的线程会处于休眠状态<br>2&gt; 需导入头文件 #import <strong>&lt;pthread.h&gt;</strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Mutex type attributes</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 普通锁</span></span><br><span class="line"><span class="meta">#define PTHREAD_MUTEX_NORMAL        0</span></span><br><span class="line"><span class="comment">// 检查错误的</span></span><br><span class="line"><span class="meta">#define PTHREAD_MUTEX_ERRORCHECK    1</span></span><br><span class="line"><span class="comment">// 递归锁</span></span><br><span class="line"><span class="meta">#define PTHREAD_MUTEX_RECURSIVE        2</span></span><br><span class="line"><span class="meta">#define PTHREAD_MUTEX_DEFAULT        PTHREAD_MUTEX_NORMAL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化锁的属性</span></span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_NORMAL)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化锁</span></span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line">pthread_mutex_init(&amp;mutex, &amp;attr);</span><br><span class="line"><span class="comment">// 尝试加锁</span></span><br><span class="line">pthread_mutex_trylock(&amp;mutex);</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="comment">// 销毁相关资源</span></span><br><span class="line">pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br></pre></td></tr></table></figure></p>
<p>将属性attr的type由PTHREAD_MUTEX_NORMAL改为 PTHREAD_MUTEX_RECURSIVE，这个锁就变成了递归锁：允许 <strong>同一个线程</strong> 对 <strong>同一把锁</strong> 进行 <strong>重复加锁</strong></p>
<h1><span id="4pthread_mutex-递归锁">4.pthread_mutex - 递归锁</span></h1><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化锁</span></span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line">pthread_mutex_init(&amp;mutex, &amp;attr);</span><br></pre></td></tr></table></figure>
<h1><span id="5pthread_mutex-条件">5.pthread_mutex - 条件</span></h1><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化锁</span></span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line"><span class="comment">// NULL代表使用默认属性</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 初始化条件</span></span><br><span class="line">pthread_cond_t condition;</span><br><span class="line">pthread_cond_init(&amp;condition, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 等待条件（进入休眠，放开mutex锁；被唤醒后，会再次对mutex加锁）</span></span><br><span class="line">pthread_cond_wait(&amp;condition, &amp;mutex);</span><br><span class="line"><span class="comment">// 激活一个等待该条件的线程</span></span><br><span class="line">pthread_cond_signal(&amp;condition);</span><br><span class="line"><span class="comment">// 激活所有等待该条件的线程</span></span><br><span class="line">pthread_cond_broadcast(&amp;condition);</span><br><span class="line"><span class="comment">// 销毁资源</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">pthread_cond_destroy(&amp;condition);</span><br></pre></td></tr></table></figure>
<h1><span id="6nslock-nsrecurisivelock">6.NSLock、NSRecurisiveLock</span></h1><p>1&gt; NSLock 是对mutex普通锁的封装<br>2&gt; NSRecursiveLock 也是对mutex递归锁的封装，API跟NSLock基本一致<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSLocking</span></span></span><br><span class="line">- (<span class="keyword">void</span>)lock;</span><br><span class="line">- (<span class="keyword">void</span>)unlock;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSLock</span> : <span class="title">NSObject</span> &lt;<span class="title">NSLocking</span>&gt;</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)tryLock;</span><br><span class="line">- (<span class="built_in">BOOL</span>)lockBeforeDate:(<span class="built_in">NSDate</span> *)limit;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>NSLock 是OC对象，再从堆栈一行一行找的话不好看锁的执行流程，因为OC对象通过消息机制执行方法，堆栈里面有很多消息机制流程，对汇编不是很熟悉的话不好断点。</p>
<p>那我们就放弃了么，NO，NO，还是可以通过 <strong><a href="http://ftpmain.gnustep.org/pub/gnustep/core/gnustep-base-1.25.0.tar.gz" target="_blank" rel="noopener">GUNStep -&gt; GNUstep Base</a></strong> 来参考下</p>
<p>GNUstep是GNU计划的项目之一，它将Cocoa的OC库重新开源实现了一遍，虽然GNUstep不是苹果官方源码，但还是具有一定的参考价值</p>
<p>源码地址：<a href="http://www.gnustep.org/resources/downloads.php" target="_blank" rel="noopener">http://www.gnustep.org/resources/downloads.php</a></p>
<p>下载之后打开工程，搜索 <strong>NSLock.m</strong>，找到 <strong>initialize</strong> 方法：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>) initialize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">BOOL</span>    beenHere = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beenHere == <span class="literal">NO</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        beenHere = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Initialise attributes for the different types of mutex.</span></span><br><span class="line"><span class="comment">        * We do it once, since attributes can be shared between multiple</span></span><br><span class="line"><span class="comment">        * mutexes.</span></span><br><span class="line"><span class="comment">        * If we had a pthread_mutexattr_t instance for each mutex, we would</span></span><br><span class="line"><span class="comment">        * either have to store it as an ivar of our NSLock (or similar), or</span></span><br><span class="line"><span class="comment">        * we would potentially leak instances as we couldn't destroy them</span></span><br><span class="line"><span class="comment">        * when destroying the NSLock.  I don't know if any implementation</span></span><br><span class="line"><span class="comment">        * of pthreads actually allocates memory when you call the</span></span><br><span class="line"><span class="comment">        * pthread_mutexattr_init function, but they are allowed to do so</span></span><br><span class="line"><span class="comment">        * (and deallocate the memory in pthread_mutexattr_destroy).</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        pthread_mutexattr_init(&amp;attr_normal);</span><br><span class="line">        pthread_mutexattr_settype(&amp;attr_normal, PTHREAD_MUTEX_NORMAL);</span><br><span class="line">        pthread_mutexattr_init(&amp;attr_reporting);</span><br><span class="line">        pthread_mutexattr_settype(&amp;attr_reporting, PTHREAD_MUTEX_ERRORCHECK);</span><br><span class="line">        pthread_mutexattr_init(&amp;attr_recursive);</span><br><span class="line">        pthread_mutexattr_settype(&amp;attr_recursive, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* To emulate OSX behavior, we need to be able both to detect deadlocks</span></span><br><span class="line"><span class="comment">        * (so we can log them), and also hang the thread when one occurs.</span></span><br><span class="line"><span class="comment">        * the simple way to do that is to set up a locked mutex we can</span></span><br><span class="line"><span class="comment">        * force a deadlock on.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        pthread_mutex_init(&amp;deadlock, &amp;attr_normal);</span><br><span class="line">        pthread_mutex_lock(&amp;deadlock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们发现，其实就是 <strong>pthread_mutex_init(&amp;deadlock, &amp;attr_normal);</strong>，所以 NSLock 其实就是对 pthread_mutex 普通锁的封装</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NSRecursiveLock</span></span><br><span class="line">- (<span class="keyword">id</span>) init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nil</span> != (<span class="keyword">self</span> = [<span class="keyword">super</span> init]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != pthread_mutex_init(&amp;_mutex, &amp;attr_recursive))</span><br><span class="line">        &#123;</span><br><span class="line">            DESTROY(<span class="keyword">self</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="7nscondition">7.NSCondition</span></h1><p>1&gt; NSCondition是对mutex和cond的封装<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSCondition</span> : <span class="title">NSObject</span> &lt;<span class="title">NSLocking</span>&gt; </span>&#123;</span><br><span class="line">- (<span class="keyword">void</span>)wait;</span><br><span class="line">- (<span class="built_in">BOOL</span>)waitUntilDate:(<span class="built_in">NSDate</span> *)limit;</span><br><span class="line">- (<span class="keyword">void</span>)signal;</span><br><span class="line">- (<span class="keyword">void</span>)broadcast;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>GNUStep实现如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nil</span> != (<span class="keyword">self</span> = [<span class="keyword">super</span> init]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != pthread_cond_init(&amp;_condition, <span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            DESTROY(<span class="keyword">self</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> != pthread_mutex_init(&amp;_mutex, &amp;attr_reporting))</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_destroy(&amp;_condition);</span><br><span class="line">            DESTROY(<span class="keyword">self</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) signal</span><br><span class="line">&#123;</span><br><span class="line">    pthread_cond_signal(&amp;_condition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) wait</span><br><span class="line">&#123;</span><br><span class="line">    pthread_cond_wait(&amp;_condition, &amp;_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1><span id="8nsconditionlock">8.NSConditionLock</span></h1><p>1&gt; NSConditionLock是对NSCondition的进一步封装，可以设置具体的条件值<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSConditionLock</span> : <span class="title">NSObject</span> &lt;<span class="title">NSLocking</span>&gt; </span>&#123;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithCondition:(<span class="built_in">NSInteger</span>)condition <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSInteger</span> condition;</span><br><span class="line">- (<span class="keyword">void</span>)lockWhenCondition:(<span class="built_in">NSInteger</span>)condition;</span><br><span class="line">- (<span class="built_in">BOOL</span>)tryLock;</span><br><span class="line">- (<span class="built_in">BOOL</span>)tryLockWhenCondition:(<span class="built_in">NSInteger</span>)condition;</span><br><span class="line">- (<span class="keyword">void</span>)unlockWithCondition:(<span class="built_in">NSInteger</span>)condition;</span><br><span class="line">- (<span class="built_in">BOOL</span>)lockBeforeDate:(<span class="built_in">NSDate</span> *)limit;</span><br><span class="line">- (<span class="built_in">BOOL</span>)lockWhenCondition:(<span class="built_in">NSInteger</span>)condition beforeDate:(<span class="built_in">NSDate</span> *)limit;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>GUNStep：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithCondition: <span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>) initWithCondition: (<span class="built_in">NSInteger</span>)value</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nil</span> != (<span class="keyword">self</span> = [<span class="keyword">super</span> init]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nil</span> == (_condition = [<span class="built_in">NSCondition</span> new]))</span><br><span class="line">        &#123;</span><br><span class="line">            DESTROY(<span class="keyword">self</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _condition_value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1><span id="9dispatch_queuedispatch_queue_serial-gcd串行队列">9.dispatch_queue(DISPATCH_QUEUE_SERIAL) GCD串行队列</span></h1><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"top.istones.moneyQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.moneyQueue, ^&#123;</span><br><span class="line">    <span class="comment">// 任务</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1><span id="10dispatch_semaphore">10.dispatch_semaphore</span></h1><p>1&gt; semaphore叫做”信号量”<br>2&gt; 信号量的初始值，可以用来控制线程并发访问的最大数量<br>3&gt; 信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 信号量的初始值</span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(value);</span><br><span class="line"><span class="comment">// 如果信号量的值 &lt;= 0，当前线程进入休眠等待（直到信号量的值 &gt; 0）</span></span><br><span class="line"><span class="comment">// 如果信号量的值 &gt; 0，就减1，然后往下执行后面的代码</span></span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"><span class="comment">// 信号量的值加1</span></span><br><span class="line">dispatch_semaphore_signal(semaphore);</span><br></pre></td></tr></table></figure>
<h1><span id="11synchronized">11.@synchronized</span></h1><p>1&gt; @synchronized是对mutex递归锁的封装<br>2&gt; 源码查看：<strong>objc4</strong>中的<strong>objc-sync.mm</strong>文件<br>3&gt; @synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@synchronized</span>(obj) &#123; <span class="comment">// objc_sync_enter</span></span><br><span class="line">    <span class="comment">// 任务</span></span><br><span class="line">&#125; <span class="comment">// objc_sync_exit</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>效率非常低，苹果已经不推荐使用，Xcode也没有提示了</p>
<p>Xcode断点，发现，@synchronized在大括号进入和退出时分别调用的是 objc_sync_enter 和 objc_sync_exit。在 objc-sync.mm 文件中搜索：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Begin synchronizing on 'obj'. </span></span><br><span class="line"><span class="comment">// Allocates recursive mutex associated with 'obj' if needed.</span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS once lock is acquired.  </span></span><br><span class="line"><span class="keyword">int</span> objc_sync_enter(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, ACQUIRE);</span><br><span class="line">        assert(data);</span><br><span class="line">        data-&gt;mutex.lock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">        <span class="keyword">if</span> (DebugNilSync) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        objc_sync_nil();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// End synchronizing on 'obj'. </span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span></span><br><span class="line"><span class="keyword">int</span> objc_sync_exit(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, RELEASE); </span><br><span class="line">        <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">bool</span> okay = data-&gt;mutex.tryUnlock();</span><br><span class="line">            <span class="keyword">if</span> (!okay) &#123;</span><br><span class="line">                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1><span id="性能">性能</span></h1><p>性能由高到低：<br>1&gt; os_unfair_lock<br>2&gt; OSSpinLock<br>3&gt; dispatch_semaphore<br>4&gt; pthread_mutex<br>5&gt; dispatch_queue(DISPATCH_QUEUE_SERIAL)<br>6&gt; NSLock<br>7&gt; NSCondition<br>8&gt; pthread_mutex(recursive)<br>9&gt; NSRecursiveLock<br>10&gt; NSConditionLock<br>11&gt; @synchronized</p>
<p>推荐使用 dispatch_semaphore、pthread_mutex，os_unfair_lock 性能虽然高，但是从 iOS10 才开始支持</p>
<h1><span id="什么情况下使用自旋锁比较划算">什么情况下使用自旋锁比较划算</span></h1><p>1&gt; 预计线程等待锁的时间很短<br>2&gt; 加锁的代码（临界区）经常被调用，但竞争很少发生<br>3&gt; CPU 资源不紧张<br>4&gt; 多核处理器</p>
<h1><span id="什么情况下使用互斥锁比较划算">什么情况下使用互斥锁比较划算</span></h1><p>1&gt; 预计线程等待锁的时间较长<br>2&gt; 单核处理器<br>3&gt; 临界区有IO操作<br>4&gt; 临界区代码复杂或者循环量大<br>5&gt; 临界区竞争非常激烈</p>
<hr>
<h1><span id="atomic">atomic</span></h1><p>1&gt; atomic用于保证属性setter、getter的原子性操作，相当于在getter和setter内部加了线程同步的锁<br>2&gt; 可以参考源码 <strong>objc4</strong> 的 <strong>objc-accessors.mm</strong><br>3&gt; 它并不能保证使用属性的过程是线程安全的（eg.一个属性array，atomic的话只能保证在外面set和get的时候线程安全，但是不能保证array addObject、removeObject线程安全）</p>
<p>提到 atomic，我们想到更多的是 nonatomic，atomic 原子性，在 macOS 中有用，在 iOS 项目中几乎不会用</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">nonatomic 和 atomic</span></span><br><span class="line"><span class="comment">atom：原子</span></span><br><span class="line"><span class="comment">atomic：原子性</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">给属性加上atomic属性修饰，可以保证属性的setter和getter都是原子性操作，也就是保证setter和getter内部都是线程同步的，相当于下面：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- (void)setName:(NSString *)name &#123;</span></span><br><span class="line"><span class="comment">    // 加锁</span></span><br><span class="line"><span class="comment">    _name = name;</span></span><br><span class="line"><span class="comment">    // 加锁</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- (NSString *)name &#123;</span></span><br><span class="line"><span class="comment">    // 加锁</span></span><br><span class="line"><span class="comment">    // 取值</span></span><br><span class="line"><span class="comment">    // 解锁</span></span><br><span class="line"><span class="comment">    // 返回</span></span><br><span class="line"><span class="comment">    return _name;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>打开objc4源码，搜索 <strong>objc-accessors.mm</strong> 文件，观察 reallySetProperty 和 objc_getProperty 方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> reallySetProperty(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> newValue, ptrdiff_t offset, <span class="keyword">bool</span> atomic, <span class="keyword">bool</span> <span class="keyword">copy</span>, <span class="keyword">bool</span> mutableCopy)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        object_setClass(<span class="keyword">self</span>, newValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> oldValue;</span><br><span class="line">    <span class="keyword">id</span> *slot = (<span class="keyword">id</span>*) ((<span class="keyword">char</span>*)<span class="keyword">self</span> + offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">copy</span>) &#123;</span><br><span class="line">        newValue = [newValue copyWithZone:<span class="literal">nil</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mutableCopy) &#123;</span><br><span class="line">        newValue = [newValue mutableCopyWithZone:<span class="literal">nil</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (*slot == newValue) <span class="keyword">return</span>;</span><br><span class="line">        newValue = objc_retain(newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!atomic) &#123;</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;        </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> objc_getProperty(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, ptrdiff_t offset, <span class="built_in">BOOL</span> atomic) &#123;</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retain release world</span></span><br><span class="line">    <span class="keyword">id</span> *slot = (<span class="keyword">id</span>*) ((<span class="keyword">char</span>*)<span class="keyword">self</span> + offset);</span><br><span class="line">    <span class="keyword">if</span> (!atomic) <span class="keyword">return</span> *slot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Atomic retain release world</span></span><br><span class="line">    spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">    slotlock.lock();</span><br><span class="line">    <span class="keyword">id</span> value = objc_retain(*slot);</span><br><span class="line">    slotlock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.</span></span><br><span class="line">    <span class="keyword">return</span> objc_autoreleaseReturnValue(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以发现，如果是atomic，就加了一把<strong>自旋锁</strong>，如果是nonatomic，直接set或返回值</p>
<hr>
<h1><span id="ios中的读写安全方案">iOS中的读写安全方案</span></h1><p>我们先思考如何实现以下场景：<br>1&gt; 同一时间，只能有1个线程进行写的操作<br>2&gt; 同一时间，允许有多个线程进行读的操作<br>3&gt; 同一时间，不允许既有写的操作，又有读的操作</p>
<p>上面的场景就是典型的“多读单写”，经常用于文件等数据的读写操作</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(read) object:<span class="literal">nil</span>] start];</span><br><span class="line">        [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(write) object:<span class="literal">nil</span>] start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - private methods</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">如果读也加上 semaphore 的话，确实可以保证读写都安全，同时只能读或者写，但是没必要。iOS中读写方案一般设计多读单写，读不涉及资源抢占，可以同时进行。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">但是，这样依然存在问题，虽然可以多读单写。但是写入加锁了，读却没有加锁，读的同时依然可以写，这个依然不可控，依然不安全，不能保证读的同时没有线程在进行写的操作。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)read &#123;</span><br><span class="line"><span class="comment">//    dispatch_semaphore_wait(self.semphore, DISPATCH_TIME_FOREVER);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    dispatch_semaphore_signal(self.semphore);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)write &#123;</span><br><span class="line">    dispatch_semaphore_wait(<span class="keyword">self</span>.semphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line"></span><br><span class="line">    dispatch_semaphore_signal(<span class="keyword">self</span>.semphore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好像简单这样用semphore的话并不能实现安全多读单写，那么怎么实现呢？</p>
<p>iOS中的实现方案有：<br>1&gt; pthread_rwlock：读写锁<br>2&gt; dispatch_barrier_async：异步栅栏调用</p>
<h4><span id="pthread_rwlock">pthread_rwlock</span></h4><p>等待锁的线程会进入休眠<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化锁</span></span><br><span class="line">pthread_rwlock_t lock;</span><br><span class="line">pthread_rwlock_init(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 读-加锁</span></span><br><span class="line">pthread_rwlock_rdlock(&amp;lock);</span><br><span class="line"><span class="comment">// 读-尝试加锁</span></span><br><span class="line">pthread_rwlock_tryrdlock(&amp;lock);</span><br><span class="line"><span class="comment">// 写-加锁</span></span><br><span class="line">pthread_rwlock_wrlock(&amp;lock);</span><br><span class="line"><span class="comment">// 写-尝试加锁</span></span><br><span class="line">pthread_rwlock_trywrlock(&amp;lock);</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">pthread_rwlock_unlock(&amp;lock);</span><br><span class="line"><span class="comment">// 销毁</span></span><br><span class="line">pthread_rwlock_destroy(&amp;lock);</span><br></pre></td></tr></table></figure></p>
<h4><span id="dispatch_barrier_async">dispatch_barrier_async</span></h4><p>1&gt; 这个函数传入的并发队列必须是自己通过dispatch_queue_cretate创建的<br>2&gt; 如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于dispatch_async函数的效果</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"top.istones.rwQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写</span></span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>读和写一定要放到一个队列里面！</p>
<p><a href="/download/线程同步方案/线程同步方案.zip"><strong>本文demo</strong></a><br><a href="/download/1.OC对象的本质/objc4-723.tar.gz"><strong>objc4</strong></a><br><a href="/download/线程同步方案/gnustep-base-1.25.0.zip"><strong>GNUstep Base</strong></a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/04/深入理解KVO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小马同学">
      <meta itemprop="description" content="iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小马同学的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/04/深入理解KVO/" itemprop="url">
                  深入理解KVO
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-04 00:52:07" itemprop="dateCreated datePublished" datetime="2018-09-04T00:52:07+08:00">2018-09-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-09-24 22:23:00" itemprop="dateModified" datetime="2018-09-24T22:23:00+08:00">2018-09-24</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS底层原理/" itemprop="url" rel="index"><span itemprop="name">iOS底层原理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>iOS | KVO | Objective-C</p>
<h2><span id="kvo的本质是什么如何手动触发kvo">KVO的本质是什么，如何手动触发KVO？</span></h2><hr>
<h2><span id="1什么是kvo">1.什么是KVO</span></h2><p>KVO的全称是Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变</p>
<p>添加监听:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="built_in">NSKeyValueObservingOptions</span> : <span class="built_in">NSUInteger</span> &#123;</span><br><span class="line">    <span class="comment">// 新值（包含于回调方法change字典中）</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptionNew</span> = <span class="number">0x01</span>,</span><br><span class="line">    <span class="comment">// 旧值（包含于回调方法change字典中）</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptionOld</span> = <span class="number">0x02</span>,</span><br><span class="line">    <span class="comment">// 观察最初的值（在注册观察服务时会调用一次触发方法）</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptionInitial</span> = <span class="number">0x04</span>,</span><br><span class="line">    <span class="comment">// 分别在值修改前后触发方法（即一次修改有两次触发）</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptionPrior</span> = <span class="number">0x08</span></span><br><span class="line">&#125; <span class="built_in">NSKeyValueObservingOptions</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">监听属性方法，方法调用者为被观察对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@param observer 观察者/订阅者</span></span><br><span class="line"><span class="comment">@param keyPath  要观察的属性 </span></span><br><span class="line"><span class="comment">@param options  监听变化条件</span></span><br><span class="line"><span class="comment">@param context  上下文，将会传递到监听回调函数中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure></p>
<p>监听回调：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object change:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span>*, <span class="keyword">id</span>&gt; *)change context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure></p>
<p>移除监听：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure></p>
<p>KVO使用大家都比较熟悉，Demo应该就没有写的必要了，下面我们直接来探索下本质</p>
<h2><span id="2kvo的本质">2.KVO的本质</span></h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.person1 = [[Person alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.person1.age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.person2 = [[Person alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.person2.age = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 &gt;&gt; 监听之前：Person, Person</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"监听之前：%@, %@"</span>, object_getClass(<span class="keyword">self</span>.person1), object_getClass(<span class="keyword">self</span>.person2));</span><br><span class="line">    <span class="comment">// 输出 &gt;&gt; 监听之前 setter 方法：0x10d2fb550, 0x10d2fb550</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"监听之前 setter 方法：%p, %p"</span>,</span><br><span class="line">    [<span class="keyword">self</span>.person1 methodForSelector:<span class="keyword">@selector</span>(setAge:)],</span><br><span class="line">    [<span class="keyword">self</span>.person2 methodForSelector:<span class="keyword">@selector</span>(setAge:)]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    [<span class="keyword">self</span>.person1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 &gt;&gt; 监听之后：NSKVONotifying_Person, Person</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"监听之前：%@, %@"</span>, object_getClass(<span class="keyword">self</span>.person1), object_getClass(<span class="keyword">self</span>.person2));</span><br><span class="line">    <span class="comment">// 输出 &gt;&gt; 监听之后 setter 方法：0x10d643bf4, 0x10d2fb550</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"监听之后 setter 方法：%p, %p"</span>,</span><br><span class="line">    [<span class="keyword">self</span>.person1 methodForSelector:<span class="keyword">@selector</span>(setAge:)],</span><br><span class="line">    [<span class="keyword">self</span>.person2 methodForSelector:<span class="keyword">@selector</span>(setAge:)]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (lldb)po ([NSKVONotifying_Person class]).superclass Person</span></span><br><span class="line">    <span class="comment">// (lldb) p (IMP)0x10d2fb550 (IMP) $0 = 0x000000010d2fb550 (KVO与KVC`-[Person setAge:] at Person.h:13)</span></span><br><span class="line">    <span class="comment">// (lldb) p (IMP)0x10d643bf4 (IMP) $1 = 0x000000010d643bf4 (Foundation`_NSSetLongLongValueAndNotify)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">self</span>.person1.age = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">self</span>.person2.age = <span class="number">25</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"监听到：%@ 的：%@ 属性值改变了，change：%@ - context：%@"</span>, object, keyPath, change, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通过断点调试，我们发现 person2 的类对象没有发生变化，person1 的类对象变成了 NSKVONotifying_Person，而且是Person的子类。</strong></p>
<p>使用 Runtime 打印 NSKVONotifying_Person 方法列表：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)printMethodNamesOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> methCount = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *methodArr = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    Method *meths = class_copyMethodList(cls, &amp;methCount);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methCount; i++) &#123;</span><br><span class="line">        Method meth = meths[i];</span><br><span class="line">        SEL sel = method_getName(meth);</span><br><span class="line">        <span class="built_in">NSString</span> *methodName = <span class="built_in">NSStringFromSelector</span>(sel);</span><br><span class="line">        [methodArr addObject:methodName];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (methodArr.count) <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, methodArr);</span><br><span class="line">    free(meths);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>NSKVONotifying_Person 实例方法列表：<ul>
<li>setAge:</li>
<li>class</li>
<li>dealloc</li>
<li>_isKVOA</li>
</ul>
</li>
</ul>
<p>总结：<br>1&gt; 添加监听时，利用RuntimeAPI动态生成Person子类： NSKVONotifying_Person ，并且使 person1 的 isa 指针指向新的类<br>2&gt; 重写 setAge: ，person1 调用 setter 方法时会从 NSKVONotifying_Person 开始查找，在自己的类对象中能够找到，所以会调用自己的 setAge：方法（ 会调用Foundation的_NSSet<strong><em>ValueAndNotify函数）<br>3&gt; _NSSet</em></strong>ValueAndNotify 调用流程：willChangeValueForKey -&gt; [super setAge:] (Person 的 setter 方法) -&gt; didChangeValueForKey（同时触发 observeValueForKeyPath 监听回调方法，订阅者接收）<br>4&gt; class 方法：重写 class 方法的目的是什么呢？<strong>(lldb) po self.person1.class  输出为：Person</strong>，原来，<strong>苹果粑粑是想要隐藏NSKVONotifying_Person，让开发者无感，使用时与未添加监听时无异</strong><br>5&gt; dealloc方法：释放 KVO 新产生的资源<br>6&gt; _isKVOA方法：标记这个新类 KVO 机制新建的</p>
<p>对<strong>willChangeValueForKey/didChangeValueForKey</strong>还有疑惑的同学可以在 Person.m 中对这两个方法进行重写，再进行调试以变理解。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="小马同学" />
            
              <p class="site-author-name" itemprop="name">小马同学</p>
              <p class="site-description motion-element" itemprop="description">iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/iStonesy" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:zzumalei@163.coem" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.jianshu.com/u/03a336dff0ec" target="_blank" title="简书"><i class="fa fa-fw fa-book"></i>简书</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小马同学</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.4.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.0"></script>



  

  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
